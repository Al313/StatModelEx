loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# Setup
data <-  read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Perform PCA on data, except country names
pca <- prcomp(data[, -1], scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of PC
loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# Data matrix: 31 x 19 spatial locations, 240 observations
pre2 <- t(array(pre, c(dim(pre)[1] * dim(pre)[2], dim(pre)[3])))
# Data matrix: 31 x 19 spatial locations, 240 observations
pre2 <- t(array(pre, c(dim(pre)[1] * dim(pre)[2], dim(pre)[3])))
# Setup
data <-  read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Perform PCA on data, except country names
pca <- prcomp(data[, -1], scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of PC
loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# load the data
loaded_obj <- load("data/prec_jan_feb.RData")
par(mfcol=c(2,2))
times <- c("00:00", "06:00", "12:00", "18:00")
for (i in 1:4){
time <- times[i]
image.plot(lon, lat, pre[, , i], main = paste0("January 1st, ", time))
map("world", add = T)
}
#install.packages("ggrepel")
#install.packages("ggplot2")
#install.packages("ggbiplot")
library(ggplot2)
library(ggrepel)
library(ggbiplot)
require(maps)
require(fields)
#install.packages("ggrepel")
#install.packages("ggplot2")
#install.packages("ggbiplot")
library(ggplot2)
library(ggrepel)
library(ggbiplot)
require(maps)
require(fields)
# Setup
data <-  read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Perform PCA on data, except country names
pca <- prcomp(data[, -1], scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of PC
loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# load the data
loaded_obj <- load("data/prec_jan_feb.RData")
par(mfcol=c(2,2))
times <- c("00:00", "06:00", "12:00", "18:00")
for (i in 1:4){
time <- times[i]
image.plot(lon, lat, pre[, , i], main = paste0("January 1st, ", time))
map("world", add = T)
}
par(mfcol=c(1,2))
mean_values <- apply(pre, c(1, 2), mean)
image.plot(lon, lat, mean_values, main = paste0("Mean Field"))
variance_values <- apply(pre, c(1, 2), var)
image.plot(lon, lat, variance_values, main = paste0("Variance Field"))
# Data matrix: 31 x 19 spatial locations, 240 observations
pre2 <- t(array(pre, c(dim(pre)[1] * dim(pre)[2], dim(pre)[3])))
# Perform PCA
pca <- prcomp(pre2, scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of top 6 PCs that explain the most variance
loadings <- pca$rotation[, 1:6]
# Plot for each loading
par(mfrow = c(2, 3))
for (i in 1:6) {
image.plot(lon, lat, matrix(loadings[, i], nrow = 31), main = paste("PC", i))
map("world", add = TRUE)
}
eigenvalues <- pca$sdev^2
par(mfrow = c(1, 1))  # Ensure single plot layout
# Create a bar plot and store the bar positions
bar_positions <- barplot(
eigenvalues,
main = "Eigenvalues of Principal Components",
xlab = "Principal Component",
ylab = "Eigenvalue",
col = "lightblue",  # Use a distinct color for bars
border = "black",   # Black border around bars
ylim = c(0, max(eigenvalues) * 1.1)  # Add some space at the top for labels
)
#Add eigenvalue labels on top of each bar
text(
bar_positions,
eigenvalues,
labels = round(eigenvalues, 2),  # Round to 2 decimal places
pos = 3,  # Position the text above the bars
cex = 0.8,  # Text size
col = "black"  # Text color
)
#Add axis labels with integer principal component indices
axis(1, at = bar_positions, labels = 1:length(eigenvalues), las = 2)  # X-axis labels
plot(cumulative_variance, type = "b", pch = 19, col = "darkgreen",
xlab = "Principal Component", ylab = "Cumulative Proportion of Variance Explained",
main = "Cumulative Variance Explained",
ylim = c(0, 1))
#install.packages("ggrepel")
#install.packages("ggplot2")
#install.packages("ggbiplot")
library(ggplot2)
library(ggrepel)
library(ggbiplot)
require(maps)
require(fields)
#install.packages("ggrepel")
#install.packages("ggplot2")
#install.packages("ggbiplot")
library(ggplot2)
library(ggrepel)
library(ggbiplot)
require(maps)
require(fields)
# Setup
data <-  read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Perform PCA on data, except country names
pca <- prcomp(data[, -1], scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of PC
loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# load the data
loaded_obj <- load("data/prec_jan_feb.RData")
par(mfcol=c(2,2))
times <- c("00:00", "06:00", "12:00", "18:00")
for (i in 1:4){
time <- times[i]
image.plot(lon, lat, pre[, , i], main = paste0("January 1st, ", time))
map("world", add = T)
}
par(mfcol=c(1,2))
mean_values <- apply(pre, c(1, 2), mean)
image.plot(lon, lat, mean_values, main = paste0("Mean Field"))
variance_values <- apply(pre, c(1, 2), var)
image.plot(lon, lat, variance_values, main = paste0("Variance Field"))
# Data matrix: 31 x 19 spatial locations, 240 observations
pre2 <- t(array(pre, c(dim(pre)[1] * dim(pre)[2], dim(pre)[3])))
# Perform PCA
pca <- prcomp(pre2, scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of top 6 PCs that explain the most variance
loadings <- pca$rotation[, 1:6]
# Plot for each loading
par(mfrow = c(2, 3))
for (i in 1:6) {
image.plot(lon, lat, matrix(loadings[, i], nrow = 31), main = paste("PC", i))
map("world", add = TRUE)
}
eigenvalues <- pca$sdev^2
par(mfrow = c(1, 1))  # Ensure single plot layout
# Create a bar plot and store the bar positions
bar_positions <- barplot(
eigenvalues,
main = "Eigenvalues of Principal Components",
xlab = "Principal Component",
ylab = "Eigenvalue",
col = "lightblue",  # Use a distinct color for bars
border = "black",   # Black border around bars
ylim = c(0, max(eigenvalues) * 1.1)  # Add some space at the top for labels
)
#Add eigenvalue labels on top of each bar
text(
bar_positions,
eigenvalues,
labels = round(eigenvalues, 2),  # Round to 2 decimal places
pos = 3,  # Position the text above the bars
cex = 0.8,  # Text size
col = "black"  # Text color
)
#Add axis labels with integer principal component indices
axis(1, at = bar_positions, labels = 1:length(eigenvalues), las = 2)  # X-axis labels
plot(cumulative_variance, type = "b", pch = 19, col = "darkgreen",
xlab = "Principal Component", ylab = "Cumulative Proportion of Variance Explained",
main = "Cumulative Variance Explained",
ylim = c(0, 1))
plot(cumulative_variance, type = "b", pch = 19, col = "darkgreen",
xlab = "Principal Component", ylab = "Cumulative Proportion of Variance Explained",
main = "Cumulative Variance Explained",
ylim = c(0, 1))
#install.packages("ggrepel")
#install.packages("ggplot2")
#install.packages("ggbiplot")
library(ggplot2)
library(ggrepel)
library(ggbiplot)
require(maps)
require(fields)
# Setup
data <-  read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Perform PCA on data, except country names
pca <- prcomp(data[, -1], scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of PC
loadings <- pca$rotation
loadings_data <- data.frame(Variable = rownames(loadings), PC1 = loadings[, 1], PC2 = loadings[, 2])
# Perform Dimensionality reduction
scores <- pca$x
pca_data <- data.frame(Country = data$Country, PC1 = scores[, 1], PC2 = scores[, 2])
ggplot() +
geom_point(data = pca_data, aes(x = PC1, y = PC2)) +
geom_text_repel(data = pca_data, aes(x = PC1, y = PC2, label = Country)) +
geom_segment(data = loadings_data, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.3, "cm")), color = "red") +
geom_text_repel(data = loadings_data, aes(x = PC1, y = PC2, label = Variable), color = "red") +
labs(title = "PCA Biplot of Protein Data", x = "PC1", y = "PC2") +
theme_minimal()
# load the data
loaded_obj <- load("data/prec_jan_feb.RData")
par(mfcol=c(2,2))
times <- c("00:00", "06:00", "12:00", "18:00")
for (i in 1:4){
time <- times[i]
image.plot(lon, lat, pre[, , i], main = paste0("January 1st, ", time))
map("world", add = T)
}
par(mfcol=c(1,2))
mean_values <- apply(pre, c(1, 2), mean)
image.plot(lon, lat, mean_values, main = paste0("Mean Field"))
variance_values <- apply(pre, c(1, 2), var)
image.plot(lon, lat, variance_values, main = paste0("Variance Field"))
# Data matrix: 31 x 19 spatial locations, 240 observations
pre2 <- t(array(pre, c(dim(pre)[1] * dim(pre)[2], dim(pre)[3])))
# Perform PCA
pca <- prcomp(pre2, scale = TRUE)
# Variance explained by each PC
screeplot(pca)
round(cumsum(pca$sdev^2 / sum(pca$sdev^2)), 3)
# Get loadings of top 6 PCs that explain the most variance
loadings <- pca$rotation[, 1:6]
# Plot for each loading
par(mfrow = c(2, 3))
for (i in 1:6) {
image.plot(lon, lat, matrix(loadings[, i], nrow = 31), main = paste("PC", i))
map("world", add = TRUE)
}
eigenvalues <- pca$sdev^2
par(mfrow = c(1, 1))  # Ensure single plot layout
# Create a bar plot and store the bar positions
bar_positions <- barplot(
eigenvalues,
main = "Eigenvalues of Principal Components",
xlab = "Principal Component",
ylab = "Eigenvalue",
col = "lightblue",  # Use a distinct color for bars
border = "black",   # Black border around bars
ylim = c(0, max(eigenvalues) * 1.1)  # Add some space at the top for labels
)
#Add eigenvalue labels on top of each bar
text(
bar_positions,
eigenvalues,
labels = round(eigenvalues, 2),  # Round to 2 decimal places
pos = 3,  # Position the text above the bars
cex = 0.8,  # Text size
col = "black"  # Text color
)
#Add axis labels with integer principal component indices
axis(1, at = bar_positions, labels = 1:length(eigenvalues), las = 2)  # X-axis labels
plot(cumulative_variance, type = "b", pch = 19, col = "darkgreen",
xlab = "Principal Component", ylab = "Cumulative Proportion of Variance Explained",
main = "Cumulative Variance Explained",
ylim = c(0, 1))
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
#install.packages("ggbiplot")
library(ggbiplot)
#install.packages("fields")
library(fields)  # for image.plot()
#install.packages("maps")
library(maps)    # for adding world borders
#install.packages("reshape2")
library(reshape2)
# Load the protein dataset
protein <- read.csv("day2/protein.txt", sep = "\t", header = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
#install.packages("ggbiplot")
library(ggbiplot)
#install.packages("fields")
library(fields)  # for image.plot()
#install.packages("maps")
library(maps)    # for adding world borders
#install.packages("reshape2")
library(reshape2)
# Load the protein dataset
protein <- read.csv("data/protein.txt", sep = "\t", header = TRUE)
# Set row names and remove the country column
rownames(protein) <- protein$Country
protein <- protein[,-1]
# Perform PCA
pca <- prcomp(protein, scale. = TRUE)
# Summary of PCA to check variance explained
pca_summary <- summary(pca)
print(pca_summary)
# Scree plot for the variance explained by each component
screeplot(pca, type = "lines", main = "Scree Plot")
ggbiplot(pca, labels = rownames(protein), ellipse = TRUE, circle = TRUE) +
ggtitle("PCA Biplot for Protein Data") + theme_minimal()
# Pairwise plot for the first four principal components
pairs(pca$x[,1:4], labels = c("PC1", "PC2", "PC3", "PC4"),
main = "Pairwise Plot of First Four Principal Components")
# Load the RData file
load("data/prec_jan_feb.RData")
# Check dimensions of the 'pre' array, should be c(31, 19, 240)
dim(pre)
# Reshape the data for the first four time slices (January 1st, 00:00 to 18:00)
pre_melted <- melt(pre[, , 1:4])  # Melt the first 4 time points (00:00, 06:00, 12:00, 18:00)
colnames(pre_melted) <- c("LongitudeIndex", "LatitudeIndex", "Time", "PrecipitableWater")
# Create data frames for longitude and latitude
lon_df <- data.frame(LongitudeIndex = 1:length(lon), Longitude = lon)
lat_df <- data.frame(LatitudeIndex = 1:length(lat), Latitude = lat)
# Merge longitude and latitude with the melted data
pre_melted <- merge(pre_melted, lon_df, by = "LongitudeIndex")
pre_melted <- merge(pre_melted, lat_df, by = "LatitudeIndex")
# Update time labels for the four times on January 1st
pre_melted$Time <- factor(pre_melted$Time, labels = c("00:00", "06:00", "12:00", "18:00"))
# Plot with ggplot2
ggplot(pre_melted, aes(x = Longitude, y = Latitude, fill = PrecipitableWater)) +
geom_raster() +
borders("world", colour = "black") +  # Add country borders
coord_fixed(xlim = c(-30, 50), ylim = c(30, 75)) +  # Focus on Europe (adjust limits)
scale_fill_viridis_c(option = "C", limits = c(min(pre_melted$PrecipitableWater),
max(pre_melted$PrecipitableWater))) +
facet_wrap(~ Time) +  # Facet by time
labs(title = "Precipitable Water on January 1st, 2000", fill = "Precipitable Water (mm)") +
theme_minimal() +  # Minimal theme for clarity
theme(
axis.title = element_blank(),       # Remove axis titles
strip.text = element_text(size = 12), # Larger facet titles
plot.title = element_text(hjust = 0.5, size = 16),  # Center and increase the size of the main title
legend.position = "right"           # Adjust legend position
)
# prepare to plot the mean and variance fields
mean_field <- apply(pre, c(1, 2), mean)
var_field <- apply(pre, c(1, 2), var)
# reshape the mean and variance fields for ggplot2
mean_melted <- melt(mean_field)
var_melted <- melt(var_field)
colnames(mean_melted) <- colnames(var_melted) <- c("LongitudeIndex", "LatitudeIndex", "Value")
#create data frames for longitude and latitude
lon_df <- data.frame(LongitudeIndex = 1:length(lon), Longitude = lon)
lat_df <- data.frame(LatitudeIndex = 1:length(lat), Latitude = lat)
# merge longitude and latitude with the melted mean and variance fields
mean_melted <- merge(mean_melted, lon_df, by = "LongitudeIndex")
mean_melted <- merge(mean_melted, lat_df, by = "LatitudeIndex")
var_melted <- merge(var_melted, lon_df, by = "LongitudeIndex")
var_melted <- merge(var_melted, lat_df, by = "LatitudeIndex")
# Plot the mean field
mean_plot <- ggplot(mean_melted, aes(x = Longitude, y = Latitude, fill = Value)) +
geom_raster() +
borders("world", colour = "black") +  # Add country borders
coord_fixed(xlim = c(-30, 50), ylim = c(30, 75)) +  # Focus on Europe
scale_fill_viridis_c(option = "C", name = "Mean") +  # Color scale for mean
labs(title = "Mean Field of Precipitable Water Data") +
theme_minimal() +
theme(axis.title = element_blank(), plot.title = element_text(hjust = 0.5, size = 16))
mean_plot
# Plot the variance field
var_plot <- ggplot(var_melted, aes(x = Longitude, y = Latitude, fill = Value)) +
geom_raster() +
borders("world", colour = "black") +  # Add country borders
coord_fixed(xlim = c(-30, 50), ylim = c(30, 75)) +  # Focus on Europe
scale_fill_viridis_c(option = "C", name = "Variance") +  # Color scale for variance
labs(title = "Variance Field of Precipitable Water Data") +
theme_minimal() +
theme(axis.title = element_blank(), plot.title = element_text(hjust = 0.5, size = 16))
var_plot
# Flatten spatial dimensions (lon and lat) into one dimension
pre_reshaped <- array_reshape(pre, c(31 * 19, 240))  # 31 (lon) * 19 (lat) by 240 (time)
install.packages("reshape2")
install.packages("reshape2")
# Flatten spatial dimensions (lon and lat) into one dimension
pre_reshaped <- array_reshape(pre, c(31 * 19, 240))  # 31 (lon) * 19 (lat) by 240 (time)
cumulative_variance <- cumsum(eigenvalues) / sum(eigenvalues)
plot(cumulative_variance, type = "b", pch = 19, col = "darkgreen",
xlab = "Principal Component", ylab = "Cumulative Proportion of Variance Explained",
main = "Cumulative Variance Explained",
ylim = c(0, 1))
abline(h = 0.9, col = "red", lty = 2)  # Reference line for 90% variance explained
## let's apply North 'rule of thumb' to the result of the pca analysis to determine how many PCs should we keep.
eigen_vals <- pca$sdev^2
for (i in 1:(length(eigen_vals)-1)){
if ((eigen_vals[i] - eigen_vals[i+1])/eigen_vals[i] < sqrt(2/length(eigen_vals))) {
pc_opt <- i
print(paste0("According to North's rule of thumb the first ", i, " PCs should be kept and the rest should be truncated!"))
break
}
}
print(paste0("With ", i, " PCs we can explain ", round(cumsum(pca$sdev^2)/sum( pca$sdev^2), 3)[pc_opt] , " of variance in the data!"))
# Load necessary library
library(MASS)
# Define the mean vector and covariance matrix
mu <- c(2, 5)
Sigma <- matrix(c(1, 1/2, 1/2, 1), nrow = 2)
# Calculate eigenvalues and eigenvectors
eigen_decomp <- eigen(Sigma)
eigenvalues <- eigen_decomp$values
eigenvectors <- eigen_decomp$vectors
# Output the eigenvalues and eigenvectors
print("Eigenvalues:")
print(eigenvalues)
print("Eigenvectors:")
print(eigenvectors)
set.seed(123)  # Set seed for reproducibility
n <- 100
data <- mvrnorm(n, mu, Sigma)
plot(data, main = "Scatter Plot of 100 Realizations", xlab = "X1", ylab = "X2", pch = 19, col = "blue")
arrows(2, 5, 2+sqrt(eigenvalues)*eigenvectors[1,], 5+sqrt(eigenvalues)*eigenvectors[2,], col = 2, lwd = 2)
legend("topright", legend = c("Eigenvector 1", "Eigenvector 2"), col = c("red", "green"), lty = 1, bty = "n")
set.seed(1)
# perform pcs
pca <- prcomp(sample, scale=FALSE)
set.seed(1)
# perform pcs
pca <- prcomp(sample, scale=FALSE)
set.seed(1)
# perform pcs
pca <- prcomp(data, scale=FALSE)
plot(pca$x, pch='.', xlab='', ylab='', cex = 6)
arrows(0, 0, eigenvectors[1, 1] * sqrt(eigenvalues[1]), eigenvectors[2, 1] * sqrt(eigenvalues[1]),
col="red", lwd=2, length=0.1)
arrows(0, 0, eigenvectors[1, 2] * sqrt(eigenvalues[2]), eigenvectors[2, 2] * sqrt(eigenvalues[2]),
col="red", lwd=2, length=0.1)
loadings <- pca$rotation  # Get PCA loadings (eigenvectors)
arrows(0, 0, loadings[1, 1] * max(abs(pca$x[, 1])), loadings[2, 1] * max(abs(pca$x[, 1])),
col="blue", lwd=2, length=0.1)
arrows(0, 0, loadings[1, 2] * max(abs(pca$x[, 2])), loadings[2, 2] * max(abs(pca$x[, 2])),
col="blue", lwd=2, length=0.1)
legend("topright", legend=c("Eigenvectors from Sigma (Covariance)", "Eigenvectors (PCA)"), col=c("red", "blue"), lwd=2)
